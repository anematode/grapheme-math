import { isTypedArray, mod, TypedArray } from '../utils.js'
import { BoundingBox } from '../other/bounding_box.js'

/**
 * Test whether three points are in counterclockwise order
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param x3
 * @param y3
 * @returns {boolean}
 */
function pointsCCW (x1, y1, x2, y2, x3, y3) {
  return (y3 - y1) * (x2 - x1) > (y2 - y1) * (x3 - x1)
}

/**
 * Returns whether two line segments (namely, (x1, y1) -- (x2, y2) and (x3, y3) -- (x4, y4)) intersect
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param x3
 * @param y3
 * @param x4
 * @param y4
 */
function lineSegmentIntersect (x1, y1, x2, y2, x3, y3, x4, y4) {
  return (
    pointsCCW(x1, y1, x3, y3, x4, y4) !== pointsCCW(x2, y2, x3, y3, x4, y4) &&
    pointsCCW(x1, y1, x2, y2, x3, y3) !== pointsCCW(x1, y1, x2, y2, x4, y4)
  )
}

// Credit to cortijon on StackOverflow! Thanks bro/sis
function getLineIntersection (p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) {
  let s1_x, s1_y, s2_x, s2_y

  s1_x = p1_x - p0_x
  s1_y = p1_y - p0_y
  s2_x = p3_x - p2_x
  s2_y = p3_y - p2_y

  const s =
    (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) /
    (-s2_x * s1_y + s1_x * s2_y)
  const t =
    (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y)

  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    // Collision detected
    const intX = p0_x + t * s1_x
    const intY = p0_y + t * s1_y

    return [intX, intY]
  }

  return null
}

/**
 * Returns whether the point p is in the triangle generated by a, b, and c. Does not specially handle NaN values and the
 * like.
 * @param px x-coordinate of point p
 * @param py y-coordinate of point p
 * @param ax x-coordinate of point a
 * @param ay y-coordinate of point a
 * @param bx x-coordinate of point b
 * @param by y-coordinate of point b
 * @param cx x-coordinate of point c
 * @param cy
 */
export function pointInTriangle (px: number, py: number, ax: number, ay: number, bx: number, by: number, cx: number, cy: number) {
  const v0x = cx - ax
  const v0y = cy - ay
  const v1x = bx - ax
  const v1y = by - ay
  const v2x = px - ax
  const v2y = py - ay

  const dot00 = v0x * v0x + v0y * v0y
  const dot01 = v0x * v1x + v0y * v1y
  const dot02 = v0x * v2x + v0y * v2y
  const dot11 = v1x * v1x + v1y * v1y
  const dot12 = v1x * v2x + v1y * v2y

  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01)

  const u = (dot11 * dot02 - dot01 * dot12) * invDenom
  const v = (dot00 * dot12 - dot01 * dot02) * invDenom

  return u >= 0 && v >= 0 && u + v < 1
}

function lineSegmentIntersectsBox (
  x1,
  y1,
  x2,
  y2,
  box_x1,
  box_y1,
  box_x2,
  box_y2
) {
  // Return the component of the line segment that resides inside a box with boundaries x in (box_x1 .. box_x2), y in
  // (box_y1 .. box_y2), which may potentially be the entire line segment.

  let pt1InBox = box_x1 <= x1 && x1 <= box_x2 && box_y1 <= y1 && y1 <= box_y2
  let pt2InBox = box_x1 <= x2 && x2 <= box_x2 && box_y1 <= y2 && y2 <= box_y2

  if (pt1InBox && pt2InBox) {
    // The line segment is entirely in the box

    return [x1, y1, x2, y2]
  }

  // Infinities cause weird problems with getLineIntersection, so we just approximate them lol
  if (x1 === Infinity) x1 = 1e6
  else if (x1 === -Infinity) x1 = -1e6
  if (x2 === Infinity) x2 = 1e6
  else if (x2 === -Infinity) x2 = -1e6
  if (y1 === Infinity) y1 = 1e6
  else if (y1 === -Infinity) y1 = -1e6
  if (y2 === Infinity) y2 = 1e6
  else if (y2 === -Infinity) y2 = -1e6

  let int1 = getLineIntersection(x1, y1, x2, y2, box_x1, box_y1, box_x2, box_y1)
  let int2 = getLineIntersection(x1, y1, x2, y2, box_x2, box_y1, box_x2, box_y2)
  let int3 = getLineIntersection(x1, y1, x2, y2, box_x2, box_y2, box_x1, box_y2)
  let int4 = getLineIntersection(x1, y1, x2, y2, box_x1, box_y2, box_x1, box_y1)

  if (!(int1 || int2 || int3 || int4) && !pt1InBox && !pt2InBox) {
    // If there are no intersections and the points are outside the box, that means none of the segment is inside the
    // box, so we can return null

    return null
  }

  let intersections = [int1, int2, int3, int4]

  if (!pt1InBox && !pt2InBox) {
    // Both points are outside of the box, but the segment intersects the box. I'm frustrated! We must RESTRICT by finding the pair of intersections with
    // maximal separation. This deals with annoying corner cases. Thankfully this code doesn't need to be too efficient
    // since this is a rare case.

    let maximalSeparationSquared = -1
    let n_x1, n_y1, n_x2, n_y2

    for (let i = 0; i < 3; ++i) {
      let i1 = intersections[i]
      if (i1) {
        for (let j = i + 1; j < 4; ++j) {
          let i2 = intersections[j]
          if (i2) {
            let dist = (i2[0] - i1[0]) ** 2 + (i2[1] - i1[1]) ** 2

            if (dist > maximalSeparationSquared) {
              maximalSeparationSquared = dist
              n_x1 = i1[0]
              n_y1 = i1[1]
              n_x2 = i2[0]
              n_y2 = i2[1]
            }
          }
        }
      }
    }

    // Swap the order if necessary. We need the result of this calculation to be in the same order as the points
    // that went in, since this will be used in the dashed line logic.
    if (n_x1 < n_x2 === x1 > x2 || n_y1 < n_y2 === y1 > y2) {
      let tmp = n_x1
      n_x1 = n_x2
      n_x2 = tmp

      tmp = n_y1
      n_y1 = n_y2
      n_y2 = tmp
    }

    return [n_x1, n_y1, n_x2, n_y2]
  }

  if (pt1InBox) {
    for (let i = 0; i < 4; ++i) {
      let intersection = intersections[i]

      if (intersection) return [x1, y1, intersection[0], intersection[1]]
    }
  } else if (pt2InBox) {
    for (let i = 0; i < 4; ++i) {
      let intersection = intersections[i]

      if (intersection) return [intersection[0], intersection[1], x2, y2]
    }
  }

  return [x1, y1, x2, y2]
}

export function generateCircleTriangleStrip (
  radius,
  x = 0,
  y = 0,
  samples = 8
) {
  const points: number[] = []

  for (let i = 0; i <= samples; ++i) {
    const angle = (i / samples) * 2 * Math.PI

    const xc = x + radius * Math.cos(angle),
      yc = y + radius * Math.sin(angle)

    if (i % 2 === 0) {
      points.push(xc, yc)
      points.push(x, y)
    } else {
      points.push(xc, yc)
    }
  }

  points.push(NaN, NaN)

  return new Float32Array(points)
}

export function generateRectangleTriangleStrip (rect) {
  const { x, y, w, h } = rect

  const points = [x, y, x + w, y, x, y + h, x + w, y + h]

  return new Float32Array(points)
}

/**
 * Given a rectangle, return a flat list of points enclosing a cycle around the rectangle.
 * @param rect {BoundingBox}
 * @returns {Float32Array}
 */
export function generateRectangleCycle (rect) {
  const { x, y, w, h } = rect

  const points = [x, y, x + w, y, x + w, y + h, x, y + h, x, y]

  return new Float32Array(points)
}

export function generateRectangleDebug (rect) {
  const { x, y, w, h } = rect

  const points = [x, y, x + w, y, x + w, y + h, x, y + h, x, y, x + w, y + w]

  return new Float32Array(points)
}

// Given a Float32Array of appropriate size, repeatedly add given triangle strips
export function combineTriangleStrips (verticesBuff) {
  let index = 0

  return arr => {
    if (arr.length === 0) return

    // Repeat previous vertex
    if (index > 0) {
      verticesBuff[index] = verticesBuff[index - 2]
      verticesBuff[index + 1] = verticesBuff[index - 1]
      verticesBuff[index + 2] = arr[0]
      verticesBuff[index + 3] = arr[1]

      index += 4
    }

    verticesBuff.set(arr, index)
    index += arr.length
  }
}

export function combineColoredTriangleStrips (verticesBuff, colorBuff) {
  let index = 0

  return (arr, { r = 0, g = 0, b = 0, a = 0 }) => {
    if (arr.length === 0) return

    // Repeat previous vertex
    if (index > 0) {
      verticesBuff[index] = verticesBuff[index - 2]
      verticesBuff[index + 1] = verticesBuff[index - 1]
      verticesBuff[index + 2] = arr[0]
      verticesBuff[index + 3] = arr[1]

      index += 4
    }

    verticesBuff.set(arr, index)
    fillRepeating(
      colorBuff,
      [r / 255, g / 255, b / 255, a / 255],
      index * 2,
      2 * (index + arr.length)
    )
    index += arr.length
  }
}

/**
 * Fill the TypedArray arr with a given pattern throughout [startIndex, endIndex). Works if either is out of bounds.
 * Worst code ever. Uses copyWithin to try make the operation FAST for large arrays (not optimized for small ones). On
 * a 50000-element array in my chrome, it provides a 16x speedup.
 * @param arr Array to fill
 * @param pattern Pattern to fill with
 * @param startIndex Index of the first instance of the pattern
 * @param endIndex Index immediately after the last instance of the pattern
 * @param patternStride Offset to begin copying the pattern
 * @returns The original array
 */
export function fillRepeating (
  arr: TypedArray,
  pattern: number[] | TypedArray,
  startIndex = 0,
  endIndex = arr.length,
  patternStride = 0
) {
  if (endIndex <= startIndex) return arr

  let patternLen = pattern.length,
    arrLen = arr.length
  if (patternLen === 0) return arr

  endIndex = Math.min(endIndex, arrLen)
  if (endIndex <= 0 || startIndex >= arrLen) return arr

  if (startIndex < 0) {
    patternStride -= startIndex
    startIndex = 0
  }

  if (patternStride !== 0) patternStride = mod(patternStride, patternLen)

  let filledEndIndex = Math.min(endIndex, startIndex + patternLen)

  let i, j
  for (
    i = startIndex, j = patternStride;
    i < filledEndIndex && j < patternLen;
    ++i, ++j
  ) {
    arr[i] = pattern[j]
  }

  // For nonzero strides
  for (j = 0; i < filledEndIndex; ++i, ++j) {
    arr[i] = pattern[j]
  }

  if (filledEndIndex === endIndex) return arr

  // We now need to iteratively copy [startIndex, startIndex + filledLen) to [startIndex + filledLen, endIndex) and
  // double filledLen accordingly. memcpy, take the wheel!
  let filledLen = patternLen

  while (true) {
    let copyLen = Math.min(filledLen, endIndex - filledEndIndex)

    arr.copyWithin(filledEndIndex, startIndex, startIndex + copyLen)
    filledEndIndex += copyLen
    filledLen += copyLen

    // Should never be greater, but whatever
    if (filledEndIndex >= endIndex) return arr
  }
}

function _flattenVec2ArrayInternal (arr) {
  const out: number[] = []

  for (let i = 0; i < arr.length; ++i) {
    let item = arr[i]

    if (item === null || item === undefined) {
      out.push(NaN, NaN)
    } else if (item.x !== undefined && item.y !== undefined) {
      out.push(item.x, item.y)
    } else if (item[0] !== undefined) {
      out.push(+item[0], item[1] ?? 0)
    } else {
      if (typeof item === 'number') out.push(item)
      else
        throw new TypeError(
          `Error when converting array to flattened Vec2 array: Unknown item ${item} at index ${i} in given array`
        )
    }
  }

  return out
}

// Given some arbitrary array of Vec2s, turn it into the regularized format [x1, y1, x2, y2, ..., xn, yn]. The end of
// one polyline and the start of another is done by one pair of numbers being NaN, NaN.
export function flattenVec2Array (arr) {
  if (isTypedArray(arr)) return arr

  for (let i = 0; i < arr.length; ++i) {
    if (typeof arr[i] !== 'number') return _flattenVec2ArrayInternal(arr)
  }

  return arr
}

export function fastAtan2 (y, x) {
  let abs_x = Math.abs(x)
  let abs_y = Math.abs(y)

  let a = abs_x < abs_y ? abs_x / abs_y : abs_y / abs_x

  // atan(x) is about x - x^3 / 3 + x^5 / 5. We also note that atan(1/x) = pi/2 - atan(x) for x > 0, etc.
  let s = a * a
  let r = ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a

  if (abs_y > abs_x) r = 1.57079637 - r
  if (x < 0.0) r = 3.14159265 - r
  if (y < 0.0) r = -r

  return r
}

/**
 * Get the approximate angle between (x1, y1), (x2, y2) and (x3, y3), an operation which should ideally be extremely
 * fast because it will be used repeatedly to know whether to refine a graph while assuming local linearity. The returned
 * angle should be between 0 and Math.PI; the closer to Math.PI, the closer to linear. I'm going to write a faster
 * version of this function soon.
 * @param x1 x-coordinate of the first point
 * @param y1 y-coordinate of the first point
 * @param x2 x-coordinate of the second point
 * @param y2 y-coordinate of the second point
 * @param x3 x-coordinate of the third point
 * @param y3 y-coordinate of the third point
 */
function approxAngleBetween (x1, y1, x2, y2, x3, y3) {
  // (x1d, y1d) = p1 ---> p2
  let x1d = x2 - x1
  let y1d = y2 - y1

  // (x3d, y3d) = p3 ---> p2
  let x3d = x2 - x3
  let y3d = y2 - y3

  let res = Math.abs(fastAtan2(y3d, x3d) - fastAtan2(y1d, x1d))
  if (res > Math.PI) {
    return 2 * Math.PI - res
  }

  return res
}

/**
 * Squared distance from a point (px, py) to the line segment (ax, ay) -- (bx, by).
 * @param px x-coordinate of p
 * @param py y-coordinate of p
 * @param ax x-coordinate of a
 * @param ay y-coordinate of a
 * @param bx x-coordinate of b
 * @param by y-coordinate of b
 * @returns Distance squared
 */
function pointLineSegmentDistanceSquared (px: number, py: number, ax: number, ay: number, bx: number, by: number): number {
  px = +px
  py = +py
  ax = +ax
  ay = +ay
  bx = +bx
  by = +by

  let t = 0.0, tx = 0.0, ty = 0.0, d = 0.0, xd = 0.0, yd = 0.0
  tx = px - ax
  ty = py - ay

  if (ax !== bx || ay !== by) {
    xd = bx - ax
    yd = by - ay

    t = (xd * (px - ax) + yd * (py - ay)) / (xd * xd + yd * yd)

    // Clamp t to [0, 1]
    if (t < 0.0) {
      t = 0.0
    } else if (t > 1.0) {
      t = 1.0
    }

    tx = ax + t * (bx - ax)
    ty = ay + t * (by - ay)

    tx = px - tx
    ty = py - ty
  }

  return tx * tx + ty * ty
}

/**
 * Distance squared between two points, p1 and p2
 * @param x1 x-coordinate of p1
 * @param y1 y-coordinate of p1
 * @param x2 x-coordinate of p2
 * @param y2 y-coordinate of p2
 */
function distanceSquared (x1, y1, x2, y2) {
  let tx = x2 - x1
  let ty = y2 - y1

  return tx * tx + ty * ty
}

/**
 * Compute Math.hypot(x, y), but since all the values of x and y we're using here are not extreme, we don't have to
 * handle overflows and underflows with much accuracy at all. We can thus use the straightforward calculation.
 * Chrome: 61.9 ms/iteration for 1e7 calculations for fastHypot; 444 ms/iteration for Math.hypot
 * @param x {number}
 * @param y {number}
 * @returns {number} hypot(x, y)
 */
export function fastHypot (x, y) {
  return Math.sqrt(x * x + y * y)
}
