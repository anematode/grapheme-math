// Series acceleration terms (see Python code)
const coeffs = [
  30122754096401.0,
  30122754096400.0,
  -30122754095752.0,
  30122754025984.0,
  -30122751049216.0,
  30122684071936.0,
  -30121767227392.0,
  30113460060160.0,
  -30060878430208.0,
  29819879292928.0,
  -29000797257728.0,
  26905671630848.0,
  -22842397687808.0,
  16865262829568.0,
  -10244436525056.0,
  4814658338816.0,
  -1619202670592.0,
  343597383680.0,
  -34359738368.0
]

const n = 18

// [...new Array(18).keys()].map(i => i+1).map(Math.log)
let precomputedLogs = [
  NaN,
  0,
  0.6931471805599453,
  1.0986122886681096,
  1.3862943611198906,
  1.6094379124341003,
  1.791759469228055,
  1.9459101490553132,
  2.0794415416798357,
  2.1972245773362196,
  2.302585092994046,
  2.3978952727983707,
  2.4849066497880004,
  2.5649493574615367,
  2.6390573296152584,
  2.70805020110221,
  2.772588722239781,
  2.833213344056216,
  2.8903717578961645
]

export function riemannZetaReal (x: number): number {
  let s = 0

  if (x > 12) {
    // extremely close to 1, use the canonical series definition

    for (let k = 1; k <= n; ++k) {
      s += Math.exp(precomputedLogs[k] * -x)
    }

    return s
  }

  for (let k = 1; k <= n; ++k) {
    let term = coeffs[k] * Math.exp(precomputedLogs[k] * -x)

    s += term
  }

  return s / (coeffs[0] * (1 - Math.exp(precomputedLogs[2] * (1 - x))))
}
