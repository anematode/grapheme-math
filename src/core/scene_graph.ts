import { WebGLRenderer } from "./renderer.js";
import { getStringID, getVersionID } from "../utils.js"
import { Scene } from "./scene.js"
import { SceneDimensions } from "../other/scene_dims.js"
import {
  RendererContextInstruction,
  RendererInstruction,
  RenderingInfo,
  SceneContextInstruction
} from "./renderer_instruction.js"

class AnnotatedSceneCopy {

}

class AnnotatedContextReducedCopy {

}

class ContextCompiledCopy {

}

/**
 * Given two instruction lists, check whether they are the same based on versions
 * @param c1
 * @param c2
 */
function differentInfo(c1: RendererContextInstruction[] | RendererInstruction[] | undefined,
                       c2: RendererContextInstruction[] | RendererInstruction[] | undefined): boolean {
  if (!c1 || !c2) return c1 === c2 // undefined case

  let len
  if ((len = c1.length) !== c2.length) return true

  for (let i = 0; i < len; ++i) {
    let c1v = c1[i]?.version
    let c2v = c2[i]?.version

    if (!c1v || !c2v || c1v !== c2v) return true
  }

  return false
}

// Corresponds one-to-one with an Element
class SceneAnnotatedNode {
  // Id of the element. If the id changes, everything under and including this element is invalidated (and is considered
  // a different element)
  id: string

  // Id of the parent; null if the top node
  parentId: string | null

  // IDs of previous children of this node; we don't use the nodes themselves so that it's a flatter structure
  children: string[]

  // Rendering info as of the last call
  rInfo: RenderingInfo

  // Version of the rendering info, autogenerated if not given by the element
  rInfoVersion: number

  // Rendering info before newest call
  lastRInfo: RenderingInfo

  // Children order before newest call
  lastChildren: string[]

  childrenOrderChanged: boolean

  rInfoChanged: boolean

  // Whether the node has been processed, as marked by a numerical ID
  processedID: number

  constructor() {
    this.rInfoVersion = -1
    this.lastChildren = this.children = []
    this.childrenOrderChanged = true
  }

  markHistorical () {
    this.lastRInfo = this.rInfo
    this.lastChildren = this.children
  }

  markInfoProcessed () {
    this.rInfoChanged = true
  }

  getVersion (): number {
    return this.rInfoVersion
  }

  /**
   * Set the info directly, overriding whether the info has the same version as before
   * @param r
   */
  setInfo (r: RenderingInfo) {
    this.rInfo = r

    if (r !== null && r.version !== undefined) {
      this.rInfoVersion = r.version
    } else {
      this.rInfoVersion = getVersionID() // auto generated
    }

    this.rInfoChanged = true
  }

  setChildrenOrder (o: string[]) {
    this.lastChildren = this.children
    this.children = o
    this.childrenOrderChanged = true
  }

  /**
   * Wheter the given rendering info is equivalent, based on version
   * @param r
   * @param checkDeep Whether to also compare versions, etc. of contexts
   * @return 00 if entirely the same, 01 if only instructions are different, 10 if only contexts are different, 11 if
   * everything is different. If checkDeep is turned off, only returns 00 or 11
   */
  differentRInfoAs (r: RenderingInfo, checkDeep=true): number {
    let tr = this.rInfo
    if (!tr || !r) {
      if (tr === r) return 0b00
      if (checkDeep) return 0b11

      return (+(r?.contexts !== tr?.contexts)) & (+(r?.instructions !== tr?.instructions) << 1)
    }

    let versionsSame = r.version === this.getVersion()
    if (versionsSame) return 0b00
    if (!checkDeep) return 0b11

    return (+differentInfo(tr.contexts, r.contexts)) & ((+differentInfo(tr.instructions, r.instructions)) << 1)
  }
}

class SceneGraphPerfCounters {
  removedElements: number
  buildCount: number

  constructor () {
    this.clear()
  }

  clear () {
    this.removedElements = 0
    this.buildCount = 0
  }
}

class SceneGraphError extends Error {
  constructor (message) {
    super(message)

    this.name = 'SceneGraphError'
  }
}

const SCENE_GRAPH_DEBUG = true

export class SceneGraph {
  id: string

  // Renderer this scene graph is attached to. Doesn't need to be attached to a renderer, in case static analysis is
  // desired
  renderer: WebGLRenderer | null

  sceneAnnotatedNodes: Map<string /* id */, SceneAnnotatedNode>
  sceneTopNode: null | string  // id of the scene node
  sceneNodeCount: number

  perfCounters: SceneGraphPerfCounters

  // one node for each context, after flattening and reordering, instructions remain uncompiled and unmerged
  // children nodes are either instructions (generally unmodified) or other contexts. Context ids are the same
  // as ids in the annotated scene
  annotatedContextNodes: Map<string, SceneAnnotatedNode>
  annotatedContextCount: number

  constructor (renderer: WebGLRenderer | null) {
    this.renderer = renderer
    this.id = getStringID()
    this.sceneAnnotatedNodes = new Map()

    this.sceneTopNode = null
    this.sceneNodeCount = -1

    this.perfCounters = new SceneGraphPerfCounters()
  }

  /**
   * Whether this scene graph has been built
   */
  hasScene (): boolean {
    return !!this.sceneTopNode
  }

  /**
   * Clear all caches, delete all buffer data
   */
  invalidateEverything () {

    this.sceneNodeCount = -1
    this.sceneAnnotatedNodes.clear()
  }

  private _getSceneRenderingInfo (scene: Scene) {
    // We traverse the scene, get rendering info, and compare it to our existing sceneAnnotatedNodes tree

    let processedID = getVersionID()
    let nodeCount = 0

    scene.apply(sceneE => {
      let id = sceneE.id, parentId = sceneE.parent ? sceneE.parent.id : null
      let annotated = this.sceneAnnotatedNodes.get(id)

      if (!annotated) {
        // New node
        annotated = new SceneAnnotatedNode()
        annotated.id = id
        annotated.parentId = parentId

        this.sceneAnnotatedNodes.set(id, annotated)
      }

      // Changed parents are supposed to be handled in the parent's context
      if (SCENE_GRAPH_DEBUG && annotated.parentId !== parentId) {
        throw new SceneGraphError(`Parent id of annotated node is ${annotated.parentId}, should be ${parentId} and processed earlier`)
      }

      let children = sceneE.getChildren()
      let rInfo = sceneE.getRenderingInfo()

      if (SCENE_GRAPH_DEBUG) {
        // Check malformed rInfo TODO
      }

      // There are three jobs to do: compare contexts, compare renderer instructions, and compare children. Reordering
      // of children is handled specially, but reordering of the others is not (too much complexity!)

      let newRInfo = annotated.differentRInfoAs(rInfo)
      if (newRInfo) {
        annotated.setInfo(rInfo)
      }

      if (children.length === 0 && annotated.children.length === 0) {
        // children unchanged

      } else {
        // Ascertain children order and remove old children if necessary

        let annotatedChildren = annotated.children
        let acl = annotatedChildren.length
        let cl = children.length
        let maxl = acl > cl ? acl : cl

        let orderChanged = false
        let newOrder: string[] = []

        // TODO optimize to prevent unncessary creation of strings when the order is unchanged

        // Look at current children and compare to annotated children
        for (let i = 0; i < maxl; ++i) {
          let child = children[i]
          let annotatedChildID = annotatedChildren[i]

          if (!child) {
            this._markSuspiciousChild(annotatedChildID, processedID)
            orderChanged = true

            continue
          }

          let childID = child.id
          newOrder.push(childID)

          if (childID !== annotatedChildID) {
            orderChanged = true

            // Potentially deleted or moved
            this._markSuspiciousChild(annotatedChildID, processedID)
          }

          let existingAnnotatedChild = this.sceneAnnotatedNodes.get(childID)
          if (existingAnnotatedChild && existingAnnotatedChild.parentId !== id) {
            // Change parent!
            existingAnnotatedChild.parentId = id
          }
        }

        if (orderChanged) {
          annotated.setChildrenOrder(newOrder)
        }
      }

      annotated.processedID = processedID // mark node as processed in this pass
      nodeCount++
    })

    this._removeUnaccountedChildren(processedID)
    this.sceneNodeCount = nodeCount
  }

  /**
   * Traverses nodes in order
   */
  forEachAnnotatedNode (callback: (node: SceneAnnotatedNode) => void) {
    let topID = this.sceneTopNode
    if (!topID) return  // nothing to traverse

    let recurse = (id: string) => {
      let node = this.sceneAnnotatedNodes.get(id)

      if (!node) throw new SceneGraphError("??")
      callback(node)
      for (let id of node.children) {
        recurse(id)
      }
    }

    recurse(topID)
  }

  /**
   * For debugging only
   */
  _flattenedAnnotatedGraphIDs (): string[] {
    let arr: string[] = []
    this.forEachAnnotatedNode(n => arr.push(n.id))

    return arr
  }

  /**
   * Child may have been moved or deleted; mark it as -1
   * @param id
   */
  private _markSuspiciousChild (id: string, processedID: number) {
    let c = this.sceneAnnotatedNodes.get(id)
    if (c && c.processedID !== processedID /* hasn't been processed previously */)
      c.processedID = -1
  }

  private _removeUnaccountedChildren(processedID: number) {
    let annotatedN = this.sceneAnnotatedNodes

    for (let key of annotatedN.keys()) {
      let node = annotatedN.get(key)!
      let nID = node.processedID

      if (nID === -1) {
        // Deleted, unclaimed child
        this.perfCounters.removedElements++
      } else if (nID !== processedID) {
        // Node has been deleted, which should have been detected! throw an error
        throw new SceneGraphError(`Unaccounted node ${node.id} (parent ${node.parentId}) still exists in scene graph`)
      }
    }
  }

  /**
   * Construct the scene graph from a scene by calling getRenderingInfo on all children, then performing an ordering
   * @param scene If null, the graph is cleared
   */
  buildFromScene (scene: Scene | null) {
    this.perfCounters.buildCount++

    let sceneID = scene?.id
    if (sceneID !== this.sceneTopNode) { // The scene has changed, invalidate everything
      this.sceneTopNode = sceneID ?? null

      this.invalidateEverything()
    }

    if (!scene) return
    this._getSceneRenderingInfo(scene)
  }

  assembleInstructions () {
    this.orderInstructions()
    this.forEachAnnotatedNode(console.log)
  }

  compile () {

  }

  // Sort and shift around instructions based on their zIndices and escapeContext status
  orderInstructions () {

  }
}
